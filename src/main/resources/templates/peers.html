<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Node RPC Dashboard</title>

    <link rel="icon" type="image/svg+xml" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="apple-touch-icon" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* ---------------------------------- */
        /* VARIABLES & BASE (DARK THEME) üåô */
        /* ---------------------------------- */
        :root {
            /* Palette Couleurs */
            --color-primary: #f0f0f0;    /* Texte principal (Light Gray) */
            --color-secondary: #aaaaaa;  /* Texte secondaire/Label (Medium Gray) */
            --color-accent: #ff9900;     /* Bitcoin Orange / Accent */
            --color-bg: #121212;         /* Arri√®re-plan global (Dark) */
            --color-card-bg: #1e1e1e;    /* Arri√®re-plan des cartes (Slightly Lighter Dark) */
            --color-border: #303030;     /* Bordures/S√©parateurs */
            --color-success: #28a745;    /* Vert Connexion/Inbound */
            --color-error: #dc3545;      /* Rouge D√©connexion/Erreur */
            --color-warning: #ffc107;    /* Jaune/Block */

            /* Ombres */
            --shadow-elevation-2: 0 6px 12px rgba(0, 0, 0, 0.5); /* Profond */
            --shadow-elevation-1: 0 2px 4px rgba(0, 0, 0, 0.4);  /* L√©ger */
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--color-bg);
            color: var(--color-primary);
            line-height: 1.5;
            padding: 20px;
        }
        #app {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: var(--color-accent);
            font-size: 2.4em;
            font-weight: 300;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        h2, h3, h4 {
            color: var(--color-primary);
            font-weight: 500;
            margin-top: 0;
            margin-bottom: 15px;
        }

        /* ---------------------------------- */
        /* STATUS & GRID üåê */
        /* ---------------------------------- */
        .status-bar {
            /* PADDING AJUST√â */
            padding: 18px 30px;
            margin-bottom: 30px;
            border-radius: 8px; /* Slightly more rounded */
            color: white;
            text-align: center;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px; /* Espace plus grand entre les statuts */
            box-shadow: var(--shadow-elevation-1);
        }
        .status-bar i { margin-right: 8px; }
        .status-connected { background-color: var(--color-success); }
        .status-disconnected {
            background-color: var(--color-error);
            animation: pulse-red 2s infinite;
        }
        /* Simple pulse animation for disconnected state */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        .status-bar p {
            margin: 5px 0 0;
            font-weight: 400;
            font-size: 0.9em;
            /* Retire le border-top qui peut √™tre moche en mode colonne */
            /* border-top: 1px solid rgba(255, 255, 255, 0.3); */
            padding-top: 5px;
            width: auto; /* Maintient la largeur auto */
        }

        /* Style pour le message d'erreur si la barre est en mode colonne */
        .status-bar.status-disconnected {
            display: flex;
            flex-direction: row; /* Force le mode ligne par d√©faut */
        }
        /* Si l'on passe en mode colonne (dans la media query mobile), on applique cette correction */
        .status-bar.is-mobile {
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
        }
        .status-bar.is-mobile p {
            width: 100%; /* Le message d'erreur prend toute la largeur */
            text-align: left;
        }


        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        .full-width {
            grid-column: 1 / -1;
        }

        /* ---------------------------------- */
        /* GENERAL CARDS */
        /* ---------------------------------- */
        .data-section {
            background-color: var(--color-card-bg);
            padding: 24px;
            border-radius: 10px; /* L√©g√®rement plus arrondi */
            box-shadow: var(--shadow-elevation-2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .data-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.7);
        }
        .data-section strong {
            font-weight: 600;
            color: var(--color-accent);
        }

        /* ---------------------------------- */
        /* OVERVIEW (STAT CARDS) */
        /* ---------------------------------- */
        .overview-row {
            grid-column: 1 / -1;
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            flex: 1;
            /* PADDING AJUST√â pour un meilleur "air" */
            padding: 25px;
            background-color: var(--color-card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-1);
            display: flex;
            flex-direction: column;
            /* UTILISATION DE GAP au lieu de space-between */
            gap: 10px;
            justify-content: flex-start; /* Aligner en haut */
            min-width: 150px;
            border-left: 5px solid var(--color-border);
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            border-left-color: var(--color-accent);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .stat-card .icon {
            font-size: 2.2em; /* L√©g√®rement plus grande */
            color: var(--color-accent);
            margin-bottom: 5px; /* R√©duit la marge */
        }

        .stat-card .value {
            font-size: 2.4em; /* Plus grand et plus impactant */
            font-weight: 700;
            color: var(--color-primary);
            line-height: 1.1;
            margin-bottom: 5px; /* Ajoute un peu d'espace avant le label */
        }

        .stat-card .label {
            font-size: 0.85em;
            color: var(--color-secondary);
            text-transform: uppercase;
            margin-top: auto; /* Pousse le label vers le bas si la carte s'√©tire */
        }

        .stat-card.peers .icon { color: var(--color-success); }
        .stat-card.blocks .icon { color: var(--color-warning); }
        .stat-card.uptime .icon { color: var(--color-accent); }
        .stat-card.version .icon { color: var(--color-secondary); }

        /* ---------------------------------- */
        /* DISTRIBUTION (PIE CHARTS) ü•ß */
        /* ---------------------------------- */
        .distribution-main-content {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .sub-card {
            flex: 1;
            padding: 0px 10px;
            border: none;
            background-color: transparent;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .sub-card h4 {
            margin: 0;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--color-accent);
            text-align: center;
            text-transform: uppercase;
            font-size: 1.1em; /* L√©g√®rement plus grand */
            letter-spacing: 1px;
        }

        .sub-card-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            align-items: center;
            justify-content: center;
        }

        .chart-container {
            width: 100%;
            max-width: 450px; /* Plus large pour les graphiques */
            height: 350px; /* Plus haut pour la l√©gende */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chart-container canvas {
            flex-grow: 1;
            width: 100% !important;
            height: 100% !important;
        }

        /* Chart.js specific styling for Dark Theme */
        .chart-container canvas {
            background-color: transparent !important;
        }

        /* ---------------------------------- */
        /* TABLES (PEERS) üìä */
        /* ---------------------------------- */
        .peer-table-wrapper {
            overflow-x: auto;
            margin-top: 15px;
            border: 1px solid var(--color-border);
            border-radius: 8px; /* Plus arrondi */
        }
        .peer-table {
            width: 100%;
            /* üõë OPTIMISATION CRITIQUE: SUPPRIMER LE MIN-WIDTH FIXE */
            min-width: unset;
            border-collapse: collapse;
            font-size: 0.85em; /* L√©g√®rement plus grand pour la lisibilit√© */
        }
        .peer-table th, .peer-table td {
            padding: 12px 18px; /* Plus de padding */
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }
        .peer-table th {
            background-color: #252525;
            font-weight: 500;
            color: var(--color-secondary);
            text-transform: uppercase;
        }
        .peer-table tbody tr:hover {
            background-color: #282828;
        }
        .peer-table .connection-type-inbound { color: var(--color-success); font-weight: 500;}
        .peer-table .connection-type-outbound { color: var(--color-accent); font-weight: 500;}

        /* ---------------------------------- */
        /* RESPONSIVE MEDIA QUERIES (Mobile Ready) üì± */
        /* ---------------------------------- */

        /* Medium screens (Tablets - 1024px) */
        @media (max-width: 1024px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            .overview-row {
                flex-wrap: wrap;
                /* üöÄ CORRECTION CRITIQUE: Forcer l'empilement vertical avec !important */
                flex-direction: column !important;
                gap: 15px;
            }
            /* Les cartes DOIVENT prendre toute la largeur disponible pour s'empiler */
            .stat-card {
                flex: 1 1 100%; /* Prend 100% de la largeur du conteneur parent */
                min-width: 100%; /* S'assurer qu'il n'y a pas de min-width restrictif */
            }
            .distribution-main-content {
                flex-direction: column;
            }
            .chart-container {
                max-width: 100%;
                height: 300px;
            }
            .peer-table {
                 min-width: 700px;
            }
        }

        /* Small screens (Mobiles - 600px) */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            body {
                padding: 10px;
            }
            .stat-card {
                padding: 20px;
                min-width: unset;
            }
            /* APPLIQUE LA CLASSE MOBILE POUR LA BARRE DE STATUT */
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                padding: 15px;
            }
            .status-bar span {
                width: 100%;
            }
            .data-section {
                padding: 15px;
                overflow: hidden;
            }
            .peer-table {
                 font-size: 0.75em;
                 min-width: auto;
            }
            .peer-table th, .peer-table td {
                padding: 8px 10px;
            }
            .peer-table-wrapper {
                 width: 100%;
            }
        }
    </style>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>

<div id="app">
    <h1><i class="fab fa-bitcoin"></i> Bitcoin Node Dashboard</h1>

    <div class="status-bar" :class="[{'status-connected': isConnected && rpcConnected, 'status-disconnected': !isConnected || !rpcConnected}, {'is-mobile': isMobile}]">
        <span><i class="fas fa-wifi"></i> WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}</span>
        <span><i class="fas fa-hdd"></i> Node RPC: {{ rpcConnected ? 'Connected' : 'Disconnected' }}</span>
        <p v-if="errorMessage" style="margin: 5px 0 0;">
            <i class="fas fa-exclamation-triangle"></i> {{ errorMessage }}
        </p>
    </div>

    <div class="dashboard-grid">

        <div class="overview-row" v-if="rpcConnected">

            <div class="stat-card peers">
                <div class="icon"><i class="fas fa-users"></i></div>
                <div class="value">{{ stats.totalPeers }}</div>
                <div class="label">Total Peers (<i class="fas fa-arrow-down"></i> {{ stats.inboundCount }} / <i class="fas fa-arrow-up"></i> {{ stats.outboundCount }})</div>
            </div>

            <div class="stat-card blocks">
                <div class="icon"><i class="fas fa-cubes"></i></div>
                <div class="value">{{ blockchain.blocks }}</div>
                <div class="label">Blocks (Chain: {{ blockchain.chain }})</div>
            </div>

            <div class="stat-card uptime">
                <div class="icon"><i class="fas fa-clock"></i></div>
                <div class="value">{{ time }}</div>
                <div class="label">Uptime</div>
            </div>

            <div class="stat-card version">
                <div class="icon"><i class="fas fa-code"></i></div>
                <div class="value">{{ cleanedSubversion }}</div>
                <div class="label">Software (P. v{{ node.protocolVersion }})</div>
            </div>
        </div>

        <div class="data-section full-width" v-else-if="isConnected && !rpcConnected">
            <p style="text-align: center; color: var(--color-secondary); font-size: 1.2em;">
                <i class="fas fa-sync fa-spin"></i> Connecting to node RPC...
            </p>
        </div>


        <div class="data-section full-width" v-if="rpcConnected">
            <h2><i class="fas fa-chart-pie"></i> SubVersion Distribution</h2>

            <div class="distribution-main-content">

                <div class="sub-card inbound-distribution">
                    <h4><i class="fas fa-sign-in-alt"></i> Inbound Peers ({{ stats.inboundCount }})</h4>

                    <div class="sub-card-content">
                        <div class="chart-container">
                            <canvas ref="inboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <div class="sub-card outbound-distribution">
                    <h4><i class="fas fa-sign-out-alt"></i> Outbound Peers ({{ stats.outboundCount }})</h4>

                    <div class="sub-card-content">
                        <div class="chart-container">
                            <canvas ref="outboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="data-section full-width" v-if="rpcConnected">
            <h2><i class="fas fa-users-cog"></i> Peer Details</h2>

            <h4>Inbound Peers ({{ inbound_peers.length }})</h4>
            <div class="peer-table-wrapper">
                <table class="peer-table">
                    <thead>
                    <tr>
                        <th>ID</th>
                        <th>Address</th>
                        <th>SubVer</th>
                        <th>Network</th> <th>Type</th>
                        <th>Ping</th>
                        <th><i class="fas fa-download"></i> Recv</th>
                        <th><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in inbound_peers" :key="'in-' + peer.id">
                        <td>{{ peer.id }}</td>
                        <td>{{ peer.addr }}</td>
                        <td>{{ peer.subver || '[Empty]' }}</td>
                        <td>{{ peer.network || 'N/A' }}</td>
                        <td class="connection-type-inbound">{{ peer.connection_type }}</td>
                        <td>{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td>{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td>{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Outbound Peers ({{ outbound_peers.length }})</h4>
            <div class="peer-table-wrapper">
                <table class="peer-table">
                    <thead>
                    <tr>
                        <th>ID</th>
                        <th>Address</th>
                        <th>SubVer</th>
                        <th>Network</th> <th>Type</th>
                        <th>Ping</th>
                        <th><i class="fas fa-download"></i> Recv</th>
                        <th><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in outbound_peers" :key="'out-' + peer.id">
                        <td>{{ peer.id }}</td>
                        <td>{{ peer.addr }}</td>
                        <td>{{ peer.subver || '[Empty]' }}</td>
                        <td>{{ peer.network || 'N/A' }}</td>
                        <td class="connection-type-outbound">{{ peer.connection_type }}</td>
                        <td>{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td>{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td>{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    const { createApp, ref, onMounted, reactive, toRefs, watch, computed, nextTick, onBeforeUnmount } = Vue;

    const DEFAULT_DATA = {
        stats: { inboundCount: 0, outboundCount: 0, totalPeers: 0 },
        blockchain: { blocks: 0, headers: 0, chain: 'Loading...' },
        node: { version: 'N/A', protocolVersion: 'N/A', subversion: 'N/A' },
        time: 'N/A', // Uptime formatted string
        inbound_peers: [],
        outbound_peers: [],
        subver_distribution: { inbound: [], outbound: [] }
    };


    /**
     * Generates a set of bright colors suitable for a dark theme.
     */
    const generateColors = (numColors) => {
        const baseColors = [
            '#007bff', '#28a745', '#ffc107', '#dc3545', '#6f42c1', '#fd7e14', '#20c997', '#6610f2',
            '#e83e8c', '#17a2b8', '#6c757d', '#adb5bd', '#343a40', '#ffe0b2', '#c8e6c9', '#bbdefb'
        ];
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }
        return colors;
    };

    /**
     * Initializes a new Chart.js instance. This should only be called once.
     */
    const initPieChart = (canvasRef, chartData) => {
        if (!canvasRef.value) return null;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        const ctx = canvasRef.value.getContext('2d');
        return new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: percentages,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8, // Slightly more aggressive hover
                    borderColor: 'transparent',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                             boxWidth: 10,
                             color: Chart.defaults.color,
                        }
                    },
                    tooltip: { // Customizing Tooltips
                         mode: 'index',
                         intersect: false,
                         callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                if (label) {
                                    return label + ': ' + context.formattedValue + '%';
                                }
                                return null;
                            }
                         }
                    },
                    title: {
                        display: false,
                    }
                }
            }
        });
    };

    /**
     * Updates an existing Chart.js instance with new data. (Fast operation)
     */
    const updateChartData = (chartInstance, chartData) => {
        if (!chartInstance) return;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = percentages;
        chartInstance.data.datasets[0].backgroundColor = backgroundColors;
        chartInstance.update();
    };


    createApp({
        setup() {
            const isConnected = ref(false);
            const rpcConnected = ref(false);
            const errorMessage = ref(null);
            // NOUVEAU: √âtat pour le responsive de la barre de statut
            const isMobile = ref(window.innerWidth <= 600);

            const dataState = reactive(DEFAULT_DATA);
            let ws = null;

            const inboundChartCanvas = ref(null);
            const outboundChartCanvas = ref(null);
            let inboundPieChart = null;
            let outboundPieChart = null;

            // Gestionnaire de redimensionnement
            const handleResize = () => {
                isMobile.value = window.innerWidth <= 600;
            };

            // Apply Chart.js global dark theme settings once
            Chart.defaults.color = '#f0f0f0';
            Chart.defaults.borderColor = '#303030';
            Chart.defaults.plugins.tooltip.backgroundColor = '#1e1e1e';
            Chart.defaults.plugins.tooltip.bodyColor = '#f0f0f0';
            Chart.defaults.plugins.tooltip.titleColor = '#aaaaaa';
            Chart.defaults.plugins.tooltip.cornerRadius = 6;


            /**
             * Processes and normalizes raw data received from the WebSocket.
             */
            const normalizeData = (rawData) => {
                const nodeInfo = rawData.nodeInfo || {};

                Object.assign(dataState, {
                    stats: rawData.generalStats || {},
                    blockchain: rawData.blockchainInfo ? {
                        blocks: rawData.blockchainInfo.blocks,
                        headers: rawData.blockchainInfo.headers,
                        chain: rawData.blockchainInfo.chain,
                    } : {},
                    node: {
                        version: nodeInfo.version,
                        protocolVersion: nodeInfo.protocolversion,
                        subversion: nodeInfo.subversion,
                    },
                    // Format uptime here before setting the state
                    time: rawData.upTime,
                    inbound_peers: rawData.inboundPeer || [],
                    outbound_peers: rawData.outboundPeer || [],
                    subver_distribution: rawData.subverDistribution || { inbound: [], outbound: [] },
                });
            };

            // CALCULATED PROPERTY TO CLEAN SUBVERSION
            const cleanedSubversion = computed(() => {
                const subver = dataState.node.subversion;
                if (!subver || subver === 'N/A') return 'N/A';
                // Remove slashes and unnecessary spaces, keep version number
                // Example: /Satoshi:25.0.0/ -> Satoshi:25.0.0
                return subver.replace(/^\/|\/$/g, '').trim();
            });


            const connectWebSocket = () => {
                // Cleanup previous connection if it exists
                if (ws) {
                    ws.onclose = null; // Prevent immediate retry on intentional close
                    ws.close();
                }

                const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
                const hostAndPort = location.host;

                ws = new WebSocket(wsProtocol + "//" + hostAndPort + "/ws/dashboard");

                ws.onopen = () => {
                    console.log("WebSocket connected!");
                    isConnected.value = true;
                };

                ws.onmessage = (event) => {
                    try {
                        const json = JSON.parse(event.data);

                        if (json.hasOwnProperty('rpcConnected')) {
                            rpcConnected.value = json.rpcConnected;
                            errorMessage.value = json.errorMessage || null;
                            return;
                        }

                        if (json.hasOwnProperty('generalStats')) {
                            rpcConnected.value = true;
                            errorMessage.value = null;
                            normalizeData(json);
                        }

                    } catch (e) {
                        console.error("Error parsing JSON message from WebSocket:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    console.log("WebSocket disconnected. Retrying in 3s...");
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket disconnected from server. Retrying...';
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket connection error.';
                };
            };

            onMounted(() => {
                connectWebSocket();
                window.addEventListener('resize', handleResize);
            });

            onBeforeUnmount(() => {
                window.removeEventListener('resize', handleResize);
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }
            });


            // OPTIMIZATION: Use the watch to update the data, and only initialize the chart once.
            watch(rpcConnected, (newVal) => {
                // If RPC connects, we ensure the chart instances are created.
                if (newVal && inboundPieChart === null && outboundPieChart === null) {
                     // Use nextTick to guarantee the DOM elements (canvas) exist after v-if is true
                     nextTick(() => { // Using imported nextTick
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subver_distribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subver_distribution.outbound);
                    });
                }
            });

            watch(() => dataState.subver_distribution.inbound, (newVal) => {
                if (inboundPieChart) {
                    updateChartData(inboundPieChart, newVal);
                }
            }, { deep: true });

            watch(() => dataState.subver_distribution.outbound, (newVal) => {
                if (outboundPieChart) {
                    updateChartData(outboundPieChart, newVal);
                }
            }, { deep: true });

            return {
                isConnected,
                rpcConnected,
                errorMessage,
                isMobile, // Return the mobile state
                ...toRefs(dataState),
                inboundChartCanvas,
                outboundChartCanvas,
                cleanedSubversion, // Return calculated property
            };
        }
    }).mount('#app');
</script>

</body>
</html>