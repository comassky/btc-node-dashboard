<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Node RPC Dashboard</title>

    <link rel="icon" type="image/svg+xml" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="apple-touch-icon" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="manifest" href="/manifest.json"> <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'bg-app': '#121212',
                        'bg-card': '#1e1e1e',
                        'border-strong': '#303030',
                        'text-primary': '#f0f0f0',
                        'text-secondary': '#aaaaaa',
                        'accent': '#ff9900', // Bitcoin Orange
                        'status-success': '#28a745',
                        'status-error': '#dc3545',
                        'status-warning': '#ffc107',
                    }
                }
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* CSS RÃ‰SIDUEL ET CRITIQUE (Animation et Chart.js) */
        body { font-family: 'Roboto', sans-serif; }

        /* Animation Pulse pour l'Ã©tat DÃ©connectÃ© */
        .pulse-red { animation: pulse-red 2s infinite; }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Ajustements de Chart.js */
        .chart-container {
            width: 100%; max-width: 450px; height: 350px; display: flex;
            flex-direction: column; align-items: center;
        }
        .chart-container canvas { flex-grow: 1; width: 100% !important; height: 100% !important; background-color: transparent !important; }

        /* Tables responsives */
        .peer-table-wrapper { overflow-x: auto; }
        .peer-table { min-width: 700px; border-collapse: collapse; }

        /* RÃ¨gle pour forcer l'empilement de la barre de statut sur les petits mobiles */
        @media (max-width: 600px) {
            .status-bar.is-mobile { flex-direction: column; align-items: flex-start; gap: 8px; }
            .status-bar.is-mobile span, .status-bar.is-mobile p { width: 100%; text-align: left; }
        }
    </style>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body class="bg-bg-app text-text-primary leading-relaxed">

<div id="app" class="p-2 md:p-4">
    <h1 class="text-center text-accent text-3xl md:text-4xl font-light mb-10 tracking-wider">
        <i class="fab fa-bitcoin"></i> Bitcoin Node Dashboard
    </h1>

    <div
            class="status-bar flex justify-center items-center gap-10 p-4 md:p-5 mb-8 rounded-lg font-medium shadow-md transition-all duration-300 ease-in-out"
            :class="[{
            'bg-status-success': isConnected && rpcConnected,
            'bg-status-error pulse-red': !isConnected || !rpcConnected
        }, {'is-mobile': isMobile}]"
    >
        <span><i class="fas fa-wifi mr-2"></i> WebSocket: **{{ isConnected ? 'Connected' : 'Disconnected' }}**</span>
        <span><i class="fas fa-hdd mr-2"></i> Node RPC: **{{ rpcConnected ? 'Connected' : 'Disconnected' }}**</span>
        <p v-if="errorMessage" class="mt-1 pt-1 border-t border-white/30 text-sm">
            <i class="fas fa-exclamation-triangle mr-2"></i> {{ errorMessage }}
        </p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-5">

        <div class="lg:col-span-2 mb-5" v-if="rpcConnected">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-5">

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-status-success hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-status-success"><i class="fas fa-users"></i></div>
                    <div class="value text-4xl font-bold text-text-primary">{{ stats.totalPeers }}</div>
                    <div class="label text-sm uppercase text-text-secondary mt-auto">Total Peers (<i class="fas fa-arrow-down"></i> {{ stats.inboundCount }} / <i class="fas fa-arrow-up"></i> {{ stats.outboundCount }})</div>
                </div>

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-status-warning hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-status-warning"><i class="fas fa-cubes"></i></div>
                    <div class="value text-4xl font-bold text-text-primary">{{ blockchain.blocks }}</div>
                    <div class="label text-sm uppercase text-text-secondary mt-auto">Blocks (Chain: {{ blockchain.chain }})</div>
                </div>

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-accent hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-accent"><i class="fas fa-clock"></i></div>
                    <div class="value text-4xl font-bold text-text-primary">{{ time }}</div>
                    <div class="label text-sm uppercase text-text-secondary mt-auto">Uptime</div>
                </div>

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-text-secondary hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-text-secondary"><i class="fas fa-code"></i></div>
                    <div class="value text-4xl font-bold text-text-primary truncate">{{ cleanedSubversion }}</div>
                    <div class="label text-sm uppercase text-text-secondary mt-auto">Software (P. v{{ node.protocolVersion }})</div>
                </div>

            </div>
        </div>

        <div class="bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-else-if="isConnected && !rpcConnected">
            <p class="text-center text-text-secondary text-lg">
                <i class="fas fa-sync fa-spin mr-2"></i> Connecting to node RPC...
            </p>
        </div>


        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-xl font-medium mb-4"><i class="fas fa-chart-pie mr-2"></i> SubVersion Distribution</h2>

            <div class="flex flex-col md:flex-row gap-5 mt-4">

                <div class="sub-card flex-1 p-0 flex flex-col gap-4">
                    <h4 class="text-lg font-medium uppercase text-center pb-1 border-b-2 border-accent tracking-wider">
                        <i class="fas fa-sign-in-alt mr-1"></i> Inbound Peers ({{ stats.inboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="inboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <div class="sub-card flex-1 p-0 flex flex-col gap-4">
                    <h4 class="text-lg font-medium uppercase text-center pb-1 border-b-2 border-accent tracking-wider">
                        <i class="fas fa-sign-out-alt mr-1"></i> Outbound Peers ({{ stats.outboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="outboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-xl font-medium mb-4"><i class="fas fa-users-cog mr-2"></i> Peer Details</h2>

            <h4 class="text-lg font-medium mt-4">Inbound Peers ({{ inbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong">
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">ID</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Address</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">SubVer</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Network</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Type</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Ping</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-download"></i> Recv</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in inbound_peers" :key="'inbound-' + peer.id" class="border-b border-border-strong hover:bg-border-strong/50 transition duration-150">
                        <td class="p-3">{{ peer.id }}</td>
                        <td class="p-3">{{ peer.addr }}</td>
                        <td class="p-3">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-3">{{ peer.network || 'N/A' }}</td>
                        <td class="p-3 font-medium text-status-success">{{ peer.connection_type }}</td>
                        <td class="p-3">{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td class="p-3">{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td class="p-3">{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h4 class="text-lg font-medium mt-8">Outbound Peers ({{ outbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong">
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">ID</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Address</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">SubVer</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Network</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Type</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Ping</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-download"></i> Recv</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in outbound_peers" :key="'outbound-' + peer.id" class="border-b border-border-strong hover:bg-border-strong/50 transition duration-150">
                        <td class="p-3">{{ peer.id }}</td>
                        <td class="p-3">{{ peer.addr }}</td>
                        <td class="p-3">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-3">{{ peer.network || 'N/A' }}</td>
                        <td class="p-3 font-medium text-accent">{{ peer.connection_type }}</td>
                        <td class="p-3">{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td class="p-3">{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td class="p-3">{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    const { createApp, ref, onMounted, reactive, toRefs, watch, computed, nextTick, onBeforeUnmount } = Vue;

    const DEFAULT_DATA = {
        stats: { inboundCount: 0, outboundCount: 0, totalPeers: 0 },
        blockchain: { blocks: 0, headers: 0, chain: 'Loading...' },
        node: { version: 'N/A', protocolVersion: 'N/A', subversion: 'N/A' },
        time: 'N/A',
        inbound_peers: [],
        outbound_peers: [],
        subver_distribution: { inbound: [], outbound: [] }
    };


    /**
     * Generates a consistent set of bright colors suitable for a dark theme.
     */
    const generateColors = (numColors) => {
        const baseColors = [
            '#00bcd4', '#ffc107', '#4caf50', '#f44336', '#9c27b0', '#ff9800', '#03a9f4', '#8bc34a',
            '#e91e63', '#607d8b', '#009688', '#cddc39', '#795548', '#ff5722', '#2196f3', '#673ab7',
            '#004d40', '#d50000', '#304ffe', '#ffea00'
        ];
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }
        return colors;
    };

    /**
     * Initializes a new Chart.js instance.
     */
    const initPieChart = (canvasRef, chartData) => {
        if (!canvasRef.value) return null;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        const ctx = canvasRef.value.getContext('2d');
        return new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: percentages,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8,
                    borderColor: 'transparent',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                             boxWidth: 10,
                             color: Chart.defaults.color,
                        }
                    },
                    tooltip: {
                         mode: 'index',
                         intersect: false,
                         callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                if (label) {
                                    return label + ': ' + context.formattedValue + '%';
                                }
                                return null;
                            }
                         }
                    },
                    title: {
                        display: false,
                    }
                }
            }
        });
    };

    /**
     * Updates an existing Chart.js instance with new data.
     */
    const updateChartData = (chartInstance, chartData) => {
        if (!chartInstance) return;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = percentages;
        chartInstance.data.datasets[0].backgroundColor = backgroundColors;
        chartInstance.update();
    };


    createApp({
        setup() {
            const isConnected = ref(false);
            const rpcConnected = ref(false);
            const errorMessage = ref(null);

            const isMobile = ref(window.innerWidth <= 600);

            const dataState = reactive(DEFAULT_DATA);
            let ws = null;

            const inboundChartCanvas = ref(null);
            const outboundChartCanvas = ref(null);
            let inboundPieChart = null;
            let outboundPieChart = null;

            const handleResize = () => {
                isMobile.value = window.innerWidth <= 600;
            };

            // Global Chart.js dark theme configuration
            Chart.defaults.color = '#f0f0f0';
            Chart.defaults.borderColor = '#303030';
            Chart.defaults.plugins.tooltip.backgroundColor = '#1e1e1e';
            Chart.defaults.plugins.tooltip.bodyColor = '#f0f0f0';
            Chart.defaults.plugins.tooltip.titleColor = '#aaaaaa';
            Chart.defaults.plugins.tooltip.cornerRadius = 6;


            const normalizeData = (rawData) => {
                const nodeInfo = rawData.nodeInfo || {};

                Object.assign(dataState, {
                    stats: rawData.generalStats || {},
                    blockchain: rawData.blockchainInfo ? {
                        blocks: rawData.blockchainInfo.blocks,
                        headers: rawData.blockchainInfo.headers,
                        chain: rawData.blockchainInfo.chain,
                    } : {},
                    node: {
                        version: nodeInfo.version,
                        protocolVersion: nodeInfo.protocolversion,
                        subversion: nodeInfo.subversion,
                    },
                    time: rawData.upTime,
                    inbound_peers: rawData.inboundPeer || [],
                    outbound_peers: rawData.outboundPeer || [],
                    subver_distribution: rawData.subverDistribution || { inbound: [], outbound: [] },
                });
            };

            const cleanedSubversion = computed(() => {
                const subver = dataState.node.subversion;
                if (!subver || subver === 'N/A') return 'N/A';
                return subver.replace(/^\/|\/$/g, '').trim();
            });


            const connectWebSocket = () => {
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }

                const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
                const hostAndPort = location.host;

                ws = new WebSocket(wsProtocol + "//" + hostAndPort + "/ws/dashboard");

                ws.onopen = () => {
                    console.log("WebSocket connected!");
                    isConnected.value = true;
                };

                ws.onmessage = (event) => {
                    try {
                        const json = JSON.parse(event.data);

                        if (json.hasOwnProperty('rpcConnected')) {
                            rpcConnected.value = json.rpcConnected;
                            errorMessage.value = json.errorMessage || null;
                            return;
                        }

                        if (json.hasOwnProperty('generalStats')) {
                            rpcConnected.value = true;
                            errorMessage.value = null;
                            normalizeData(json);
                        }

                    } catch (e) {
                        console.error("Error parsing JSON message from WebSocket:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    console.log("WebSocket disconnected. Retrying in 3s...");
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket disconnected from server. Retrying...';
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket connection error.';
                };
            };

            onMounted(() => {
                connectWebSocket();
                window.addEventListener('resize', handleResize);

                // ðŸŸ¢ ENREGISTREMENT DU SERVICE WORKER (PWA)
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => console.log('Service Worker enregistrÃ©. Scope:', registration.scope))
                        .catch(error => console.error('Ã‰chec de l\'enregistrement du Service Worker:', error));
                }
            });

            onBeforeUnmount(() => {
                window.removeEventListener('resize', handleResize);
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }
            });

            // Initialisation des graphiques
            watch(rpcConnected, (newVal) => {
                if (newVal && inboundPieChart === null && outboundPieChart === null) {
                     nextTick(() => {
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subver_distribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subver_distribution.outbound);
                    });
                }
            });

            // Mise Ã  jour des donnÃ©es des graphiques
            watch(() => dataState.subver_distribution.inbound, (newVal) => {
                if (inboundPieChart) { updateChartData(inboundPieChart, newVal); }
            }, { deep: true });

            watch(() => dataState.subver_distribution.outbound, (newVal) => {
                if (outboundPieChart) { updateChartData(outboundPieChart, newVal); }
            }, { deep: true });

            return {
                isConnected,
                rpcConnected,
                errorMessage,
                isMobile,
                ...toRefs(dataState),
                inboundChartCanvas,
                outboundChartCanvas,
                cleanedSubversion,
            };
        }
    }).mount('#app');
</script>

</body>
</html>