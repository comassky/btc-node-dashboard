<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Node RPC Dashboard</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* ---------------------------------- */
        /* VARIABLES & BASE (DARK THEME) */
        /* ---------------------------------- */
        :root {
            --color-primary: #f0f0f0;
            --color-secondary: #aaaaaa;
            --color-accent: #007bff;
            --color-bg: #121212;
            --color-card-bg: #1e1e1e;
            --color-border: #303030;
            --color-success: #4caf50;
            --color-error: #f44336;
            --color-warning: #ff9800;
            --color-table-header: #252525; /* New variable for clarity */
            --color-table-hover: #282828; /* New variable for clarity */

            --shadow-elevation-2: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-elevation-1: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--color-bg);
            color: var(--color-primary);
            line-height: 1.5;
            padding: 20px;
        }
        #app {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: var(--color-accent);
            font-size: 2.2em;
            font-weight: 400;
            margin-bottom: 40px;
            letter-spacing: 1px;
        }
        h2, h3, h4 {
            color: var(--color-primary);
            font-weight: 500;
            margin-top: 0;
            margin-bottom: 15px;
        }

        /* ---------------------------------- */
        /* STATUS & GRID */
        /* ---------------------------------- */
        .status-bar {
            padding: 15px;
            margin-bottom: 30px;
            border-radius: 4px;
            color: white;
            text-align: center;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            box-shadow: var(--shadow-elevation-1);
        }
        .status-bar i { margin-right: 8px; }
        .status-connected { background-color: var(--color-success); }
        .status-disconnected { background-color: var(--color-error); }
        .status-bar p { margin: 5px 0 0; font-weight: 400; font-size: 0.9em; border-top: 1px solid rgba(255, 255, 255, 0.3); padding-top: 5px;}

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        .full-width {
            grid-column: 1 / -1;
        }

        /* ---------------------------------- */
        /* GENERAL CARDS */
        /* ---------------------------------- */
        .data-section {
            background-color: var(--color-card-bg);
            padding: 24px;
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-2);
            transition: box-shadow 0.3s ease;
        }
        .data-section:hover {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6), 0 6px 6px rgba(0, 0, 0, 0.5);
        }
        .data-section strong {
            font-weight: 600;
            color: var(--color-accent);
        }

        /* ---------------------------------- */
        /* OVERVIEW (STAT CARDS) */
        /* ---------------------------------- */
        .overview-row {
            grid-column: 1 / -1;
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            flex: 1;
            padding: 20px;
            background-color: var(--color-card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-width: 150px;
        }

        .stat-card .icon {
            font-size: 2em;
            color: var(--color-accent);
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: 600;
            color: var(--color-primary);
        }

        .stat-card .label {
            font-size: 0.9em;
            color: var(--color-secondary);
            text-transform: uppercase;
        }

        .stat-card.peers .icon { color: var(--color-success); }
        .stat-card.blocks .icon { color: var(--color-warning); }
        .stat-card.uptime .icon { color: var(--color-accent); }
        .stat-card.version .icon { color: var(--color-secondary); }

        /* ---------------------------------- */
        /* DISTRIBUTION (MINIMALIST SUB-CARDS) */
        /* ---------------------------------- */
        .distribution-main-content {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .sub-card {
            flex: 1;
            padding: 0px 10px;
            border: none;
            background-color: transparent;

            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .sub-card h4 {
            margin: 0;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--color-border);
            text-align: center;
        }

        .sub-card-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            align-items: center;
        }

        .chart-container {
            width: 100%;
            max-width: 350px;
            height: 250px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chart-container canvas {
            flex-grow: 1;
            width: 100% !important;
            height: 100% !important;
        }

        .sub-card-list {
             width: 100%;
             max-height: 200px;
             overflow-y: auto;
             border: 1px solid var(--color-border);
             padding: 10px;
             border-radius: 4px;
        }
        .sub-card-list ul {
             list-style: none;
             padding: 0;
             margin: 0;
             font-size: 0.8em;
        }
        .sub-card-list ul li {
            padding: 3px 0;
            color: var(--color-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Chart.js specific styling for Dark Theme */
        .chart-container canvas {
            background-color: transparent !important;
        }

        /* ---------------------------------- */
        /* TABLES (PEERS) */
        /* ---------------------------------- */
        .peer-table-wrapper {
            overflow-x: auto;
            margin-top: 15px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }
        .peer-table {
            width: 100%;
            min-width: 800px;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .peer-table th, .peer-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }
        .peer-table th {
            background-color: var(--color-table-header);
            font-weight: 500;
            color: var(--color-secondary);
            text-transform: uppercase;
        }
        .peer-table tbody tr:hover {
            background-color: var(--color-table-hover);
        }

        /* ---------------------------------- */
        /* RESPONSIVE MEDIA QUERIES */
        /* ---------------------------------- */

        /* Medium screens (Tablets - 1024px) */
        @media (max-width: 1024px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            .overview-row {
                flex-wrap: wrap;
            }
            .stat-card {
                flex: 1 1 45%;
            }
            .distribution-main-content {
                flex-direction: column;
            }
            .chart-container {
                max-width: 350px;
            }
        }

        /* Small screens (Mobiles - 600px) */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }
            body {
                padding: 10px;
            }
            .overview-row {
                flex-direction: column;
            }
            .stat-card {
                flex: 1 1 100%;
            }
            .chart-container {
                max-width: 100%;
            }
            .sub-card-list {
                 max-height: 150px;
            }
            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>

<div id="app">
    <h1><i class="fas fa-satellite-dish"></i> Bitcoin Node Dashboard</h1>

    <div class="status-bar" :class="{'status-connected': isConnected && rpcConnected, 'status-disconnected': !isConnected || !rpcConnected}">
        <span><i class="fas fa-wifi"></i> WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}</span>
        <span><i class="fas fa-hdd"></i> Node RPC: {{ rpcConnected ? 'Connected' : 'Disconnected' }}</span>
        <p v-if="errorMessage" style="margin: 5px 0 0;">
            <i class="fas fa-exclamation-triangle"></i> {{ errorMessage }}
        </p>
    </div>

    <div class="dashboard-grid">

        <div class="overview-row" v-if="rpcConnected">

            <div class="stat-card peers">
                <div class="icon"><i class="fas fa-users"></i></div>
                <div class="value">{{ stats.totalPeers }}</div>
                <div class="label">Total Peers (<i class="fas fa-arrow-down"></i> {{ stats.inboundCount }} / <i class="fas fa-arrow-up"></i> {{ stats.outboundCount }})</div>
            </div>

            <div class="stat-card blocks">
                <div class="icon"><i class="fas fa-cubes"></i></div>
                <div class="value">{{ blockchain.blocks }}</div>
                <div class="label">Blocks (Chain: {{ blockchain.chain }})</div>
            </div>

            <div class="stat-card uptime">
                <div class="icon"><i class="fas fa-clock"></i></div>
                <div class="value">{{ time }}</div>
                <div class="label">Uptime</div>
            </div>

            <div class="stat-card version">
                <div class="icon"><i class="fas fa-code"></i></div>
                <div class="value">v{{ node.protocolVersion }}</div>
                <div class="label">Protocol</div>
            </div>

        </div>

        <div class="data-section full-width" v-else-if="isConnected && !rpcConnected">
            <p style="text-align: center; color: var(--color-info); font-size: 1.2em;">
                <i class="fas fa-sync fa-spin"></i> Connecting to node RPC...
            </p>
        </div>


        <div class="data-section full-width" v-if="rpcConnected">
            <h2><i class="fas fa-code-branch"></i> SubVersion Distribution</h2>

            <div class="distribution-main-content">

                <div class="sub-card inbound-distribution">
                    <h4><i class="fas fa-arrow-right"></i> Inbound Peers ({{ stats.inboundCount }})</h4>

                    <div class="sub-card-content">
                        <div class="chart-container">
                            <canvas ref="inboundChartCanvas"></canvas>
                        </div>

                        <div class="sub-card-list">
                            <ul>
                                <li v-for="item in subver_distribution.inbound" :key="'inbound-list-' + item.server">
                                    <code>{{ item.server || '[Unknown]' }}</code> : <strong>{{ item.percentage }}%</strong>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-card outbound-distribution">
                    <h4><i class="fas fa-arrow-left"></i> Outbound Peers ({{ stats.outboundCount }})</h4>

                    <div class="sub-card-content">
                        <div class="chart-container">
                            <canvas ref="outboundChartCanvas"></canvas>
                        </div>

                        <div class="sub-card-list">
                            <ul>
                                <li v-for="item in subver_distribution.outbound" :key="'outbound-list-' + item.server">
                                    <code>{{ item.server || '[Unknown]' }}</code> : <strong>{{ item.percentage }}%</strong>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="data-section full-width" v-if="rpcConnected">
            <h2><i class="fas fa-users"></i> Peer Details</h2>

            <h4>Inbound Peers ({{ inbound_peers.length }})</h4>
            <div class="peer-table-wrapper">
                <table class="peer-table">
                    <thead>
                    <tr>
                        <th>ID</th>
                        <th>Address</th>
                        <th>SubVer</th>
                        <th>Type</th>
                        <th>Ping</th>
                        <th><i class="fas fa-download"></i> Recv</th>
                        <th><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in inbound_peers" :key="'in-' + peer.id">
                        <td>{{ peer.id }}</td>
                        <td>{{ peer.addr }}</td>
                        <td>{{ peer.subver || '[Empty]' }}</td>
                        <td>{{ peer.connection_type }}</td>
                        <td>{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td>{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td>{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Outbound Peers ({{ outbound_peers.length }})</h4>
            <div class="peer-table-wrapper">
                <table class="peer-table">
                    <thead>
                    <tr>
                        <th>ID</th>
                        <th>Address</th>
                        <th>SubVer</th>
                        <th>Type</th>
                        <th>Ping</th>
                        <th><i class="fas fa-download"></i> Recv</th>
                        <th><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in outbound_peers" :key="'out-' + peer.id">
                        <td>{{ peer.id }}</td>
                        <td>{{ peer.addr }}</td>
                        <td>{{ peer.subver || '[Empty]' }}</td>
                        <td>{{ peer.connection_type }}</td>
                        <td>{{ peer.minping ? peer.minping.toFixed(3) + ' s' : 'N/A' }}</td>
                        <td>{{ (peer.bytesrecv / 1024).toFixed(2) }} KB</td>
                        <td>{{ (peer.bytessent / 1024).toFixed(2) }} KB</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    const { createApp, ref, onMounted, reactive, toRefs, watch } = Vue;

    const DEFAULT_DATA = {
        stats: { inboundCount: 0, outboundCount: 0, totalPeers: 0 },
        blockchain: { blocks: 0, headers: 0, chain: 'Loading...' },
        node: { version: 'N/A', protocolVersion: 'N/A', subversion: 'N/A' },
        time: 'N/A', // Uptime formatted string
        inbound_peers: [],
        outbound_peers: [],
        subver_distribution: { inbound: [], outbound: [] }
    };


    /**
     * Generates a set of bright colors suitable for a dark theme.
     */
    const generateColors = (numColors) => {
        const baseColors = [
            '#007bff', '#28a745', '#ffc107', '#dc3545', '#6f42c1', '#fd7e14', '#20c997', '#6610f2',
            '#e83e8c', '#17a2b8', '#6c757d', '#adb5bd', '#343a40', '#ffe0b2', '#c8e6c9', '#bbdefb'
        ];
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }
        return colors;
    };

    /**
     * Initializes a new Chart.js instance. This should only be called once.
     */
    const initPieChart = (canvasRef, chartData) => {
        if (!canvasRef.value) return null;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        const ctx = canvasRef.value.getContext('2d');
        return new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: percentages,
                    backgroundColor: backgroundColors,
                    hoverOffset: 4,
                    borderColor: 'transparent',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                             boxWidth: 10,
                             color: Chart.defaults.color, // Use the defined default color
                        }
                    },
                    title: {
                        display: false,
                    }
                }
            }
        });
    };

    /**
     * Updates an existing Chart.js instance with new data. (Fast operation)
     */
    const updateChartData = (chartInstance, chartData) => {
        if (!chartInstance) return;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = percentages;
        chartInstance.data.datasets[0].backgroundColor = backgroundColors;
        chartInstance.update();
    };


    createApp({
        setup() {
            const isConnected = ref(false);
            const rpcConnected = ref(false);
            const errorMessage = ref(null);

            const dataState = reactive(DEFAULT_DATA);
            let ws = null;

            const inboundChartCanvas = ref(null);
            const outboundChartCanvas = ref(null);
            let inboundPieChart = null;
            let outboundPieChart = null;

            // Apply Chart.js global dark theme settings once
            Chart.defaults.color = '#f0f0f0';
            Chart.defaults.borderColor = '#303030';
            Chart.defaults.plugins.tooltip.backgroundColor = '#1e1e1e';
            Chart.defaults.plugins.tooltip.bodyColor = '#f0f0f0';
            Chart.defaults.plugins.tooltip.titleColor = '#aaaaaa';


            /**
             * Processes and normalizes raw data received from the WebSocket.
             */
            const normalizeData = (rawData) => {
                const nodeInfo = rawData.nodeInfo || {};

                Object.assign(dataState, {
                    stats: rawData.generalStats || {},
                    blockchain: rawData.blockchainInfo ? {
                        blocks: rawData.blockchainInfo.blocks,
                        headers: rawData.blockchainInfo.headers,
                        chain: rawData.blockchainInfo.chain,
                    } : {},
                    node: {
                        version: nodeInfo.version,
                        protocolVersion: nodeInfo.protocolversion,
                        subversion: nodeInfo.subversion,
                    },
                    // Format uptime here before setting the state
                    time: rawData.upTime,
                    inbound_peers: rawData.inboundPeer || [],
                    outbound_peers: rawData.outboundPeer || [],
                    subver_distribution: rawData.subverDistribution || { inbound: [], outbound: [] },
                });
            };

            const connectWebSocket = () => {
                const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
                const hostAndPort = location.host;

                ws = new WebSocket(wsProtocol + "//" + hostAndPort + "/ws/dashboard");

                ws.onopen = () => {
                    console.log("WebSocket connected!");
                    isConnected.value = true;
                };

                ws.onmessage = (event) => {
                    try {
                        const json = JSON.parse(event.data);

                        if (json.hasOwnProperty('rpcConnected')) {
                            rpcConnected.value = json.rpcConnected;
                            errorMessage.value = json.errorMessage || null;
                            return;
                        }

                        if (json.hasOwnProperty('generalStats')) {
                            rpcConnected.value = true;
                            errorMessage.value = null;
                            normalizeData(json);
                        }

                    } catch (e) {
                        console.error("Error parsing JSON message from WebSocket:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    console.log("WebSocket disconnected. Retrying in 3s...");
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket disconnected from server. Retrying...';
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket connection error.';
                };
            };

            onMounted(() => {
                connectWebSocket();

                // Important: Initialize charts immediately on mount (or with nextTick)
                // We use nextTick to ensure the canvas elements are rendered by v-if="rpcConnected"
                // before trying to grab their refs, minimizing the delay.
                // However, since the charts are inside a v-if, we must use `watch`
                // on the ref value itself, or wait until `rpcConnected` is true,
                // but the current setup relies on the watch below for the first data load anyway.
            });

            // OPTIMIZATION: Use the watch to update the data, and only initialize the chart once.
            // This ensures the heavy `new Chart()` operation is only run if the chart instance is null.

            watch(rpcConnected, (newVal) => {
                // If RPC connects, we ensure the chart instances are created.
                if (newVal && inboundPieChart === null && outboundPieChart === null) {
                     // Use nextTick to guarantee the DOM elements (canvas) exist after v-if is true
                     Vue.nextTick(() => {
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subver_distribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subver_distribution.outbound);
                    });
                }
            });

            watch(() => dataState.subver_distribution.inbound, (newVal) => {
                if (inboundPieChart) {
                    updateChartData(inboundPieChart, newVal);
                }
            }, { deep: true });

            watch(() => dataState.subver_distribution.outbound, (newVal) => {
                if (outboundPieChart) {
                    updateChartData(outboundPieChart, newVal);
                }
            }, { deep: true });

            return {
                isConnected,
                rpcConnected,
                errorMessage,
                ...toRefs(dataState),
                inboundChartCanvas,
                outboundChartCanvas,
            };
        }
    }).mount('#app');
</script>

</body>
</html>