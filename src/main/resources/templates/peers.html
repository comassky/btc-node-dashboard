<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Node RPC Dashboard</title>

    <link rel="icon" type="image/svg+xml" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="apple-touch-icon" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="manifest" href="/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Tailwind configuration for dark mode and Bitcoin colors
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'bg-app': '#121212',
                        'bg-card': '#1e1e1e',
                        'border-strong': '#303030',
                        'text-primary': '#f0f0f0',
                        'text-secondary': '#aaaaaa',
                        'accent': '#ff9900', // Bitcoin Orange
                        'status-success': '#28a745',
                        'status-error': '#dc3545',
                        'status-warning': '#ffc107',
                    }
                }
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <style>
        /* OPTIMIZED CRITICAL CSS (Animation and Chart.js adjustments) */
        body { font-family: 'Roboto', sans-serif; }

        /* Pulse Animation for Disconnected state */
        .pulse-red { animation: pulse-red 2s infinite; }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Chart.js size adjustments */
        .chart-container {
            width: 100%; max-width: 450px; height: 350px; display: flex;
            flex-direction: column; align-items: center;
        }
        /* Important to ensure canvas is responsive within its container */
        .chart-container canvas { flex-grow: 1; width: 100% !important; height: 100% !important; background-color: transparent !important; }

        /* Responsive tables setup for horizontal scroll on small screens */
        .peer-table-wrapper {
            overflow-x: auto;
        }
        .peer-table {
            border-collapse: collapse;
            /* Ensures table takes necessary width for content before enabling scroll */
            width: max-content;
        }
        .peer-table th, .peer-table td {
            /* Prevents long content from wrapping if it's a single string */
            white-space: nowrap;
        }

        /* Rule to force status bar stacking on small mobiles */
        @media (max-width: 600px) {
            .status-bar.is-mobile { flex-direction: column; align-items: flex-start; gap: 8px; }
            .status-bar.is-mobile span, .status-bar.is-mobile p { width: 100%; text-align: left; }
        }
    </style>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
</head>
<body class="bg-bg-app text-text-primary leading-relaxed">

<div id="app" class="p-2 md:p-4">
    <h1 class="text-center text-accent text-3xl md:text-4xl font-light mb-10 tracking-wider">
        <i class="fab fa-bitcoin"></i> Bitcoin Node Dashboard
    </h1>

    <div
            class="status-bar flex justify-center items-center gap-10 p-4 md:p-5 mb-8 rounded-lg font-medium shadow-md transition-all duration-300 ease-in-out"
            :class="[{
            'bg-status-success': isConnected && rpcConnected,
            'bg-status-error pulse-red': !isConnected || !rpcConnected
        }, {'is-mobile': isMobile}]"
    >
        <span :title="isConnected ? 'WebSocket link is active and open' : 'WebSocket disconnected. Retrying connection...'">
            <i class="fas fa-wifi mr-2"></i> WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}
        </span>
        <span :title="rpcConnected ? 'Node is responding to RPC commands' : 'RPC connection lost or not yet established'">
            <i class="fas fa-hdd mr-2"></i> Node RPC: {{ rpcConnected ? 'Connected' : 'Disconnected' }}
        </span>
        <p v-if="errorMessage" class="mt-1 pt-1 border-t border-white/30 text-sm">
            <i class="fas fa-exclamation-triangle mr-2"></i> {{ errorMessage }}
        </p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-5">

        <div class="lg:col-span-2 mb-5" v-if="rpcConnected">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-5">

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-status-success hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-status-success"><i class="fas fa-users"></i></div>
                    <div class="value text-4xl font-bold text-text-primary">{{ stats.totalPeers }}</div>
                    <div class="detail mt-2 pt-2 border-t border-border-strong text-sm text-text-secondary">
                        <p class="mb-1"><i class="fas fa-arrow-down mr-1"></i> Inbound: {{ stats.inboundCount }}</p>
                        <p class="mb-1"><i class="fas fa-arrow-up mr-1"></i> Outbound: {{ stats.outboundCount }}</p>
                    </div>
                    <div class="label text-sm uppercase text-text-secondary mt-auto">Total Peers</div>
                </div>

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-status-warning hover:border-accent transition duration-200 flex flex-col gap-3">
                    <div class="icon text-3xl text-status-warning"><i class="fas fa-cubes"></i></div>
                    <div class="value text-4xl font-bold text-text-primary" :title="'Current height of the ' + blockchain.chain + ' blockchain'">{{ blockchain.blocks }}</div>

                    <div class="detail mt-2 pt-2 border-t border-border-strong text-sm text-text-secondary">
                        <p class="mb-1"><i class="fas fa-list-ol mr-1"></i> Headers: <span class="font-bold text-text-primary">{{ blockchain.headers }}</span></p>
                    </div>

                    <div class="label text-sm uppercase text-text-secondary mt-auto">Blocks (Chain: {{ blockchain.chain }})</div>
                </div>

                <div class="stat-card bg-bg-card p-6 rounded-xl shadow-xl border-l-4 border-accent hover:border-accent transition duration-200 flex flex-col gap-3 lg:col-span-2">
                    <div class="icon text-3xl text-text-secondary"><i class="fas fa-server"></i></div>
                    <div class="label text-sm uppercase text-text-secondary">Node Status</div>

                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-end">

                        <div class="min-w-0 flex-shrink">
                            <div class="value text-xl font-bold text-text-primary truncate" :title="cleanedSubversion">{{ cleanedSubversion }}</div>
                            <div class="detail text-xs text-text-secondary">Protocol v{{ node.protocolVersion }}</div>
                        </div>

                        <div class="text-left sm:text-right mt-3 sm:mt-0 flex-shrink-0">
                            <div class="value text-xl font-bold text-text-primary" title="Time elapsed since node started">{{ upTime }}</div>
                            <div class="detail text-xs text-text-secondary">Uptime</div>
                        </div>
                    </div>
                    <div class="detail mt-3 pt-3 border-t border-border-strong text-sm text-text-secondary">
                        <p class="mb-1">
                            <i class="fas fa-check-circle mr-1 text-status-success"></i> Verification Progress:
                            <span class="font-bold text-text-primary ml-1">{{ (blockchain.verificationProgress * 100).toFixed(4) }}%</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-else-if="isConnected && !rpcConnected">
            <p class="text-center text-text-secondary text-lg">
                <i class="fas fa-sync fa-spin mr-2"></i> Connecting to node RPC...
            </p>
        </div>

        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-xl font-medium mb-4"><i class="fas fa-chart-pie mr-2"></i> SubVersion Distribution</h2>

            <div class="flex flex-col md:flex-row gap-5 mt-4">

                <div class="sub-card flex-1 p-0 flex flex-col gap-4">
                    <h4 class="text-lg font-medium uppercase text-center pb-1 border-b-2 border-accent tracking-wider">
                        <i class="fas fa-sign-in-alt mr-1"></i> Inbound Peers ({{ stats.inboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="inboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <div class="sub-card flex-1 p-0 flex flex-col gap-4">
                    <h4 class="text-lg font-medium uppercase text-center pb-1 border-b-2 border-accent tracking-wider">
                        <i class="fas fa-sign-out-alt mr-1"></i> Outbound Peers ({{ stats.outboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="outboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-xl font-medium mb-4"><i class="fas fa-users-cog mr-2"></i> Peer Details</h2>

            <h4 class="text-lg font-medium mt-4">Inbound Peers ({{ inbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong">
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">ID</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Address</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">SubVer</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Version</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Offset (s)</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Time</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Network</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Type</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Ping</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-download"></i> Recv</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in inbound_peers" :key="'inbound-' + peer.id" class="border-b border-border-strong hover:bg-border-strong/50 transition duration-150">
                        <td class="p-3">{{ peer.id }}</td>
                        <td class="p-3" :title="peer.addr">{{ peer.addr }}</td>
                        <td class="p-3" :title="peer.subver">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-3">{{ peer.version }}</td>
                        <td class="p-3">{{ formatTimeOffset(peer.timeoffset) }}</td>
                        <td class="p-3">{{ formatTimeSince(peer.conntime) }}</td>
                        <td class="p-3">{{ peer.network || 'N/A' }}</td>
                        <td class="p-3 font-medium text-status-success" :title="'Connection type: ' + peer.connection_type">{{ peer.connection_type }}</td>
                        <td class="p-3">{{ formatPing(peer.minping) }}</td>
                        <td class="p-3" :title="peer.bytesrecv + ' Bytes'">{{ formatBytes(peer.bytesrecv) }}</td>
                        <td class="p-3" :title="peer.bytessent + ' Bytes'">{{ formatBytes(peer.bytessent) }}</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h4 class="text-lg font-medium mt-8">Outbound Peers ({{ outbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong">
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">ID</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Address</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">SubVer</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Version</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Offset (s)</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Time</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Network</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Type</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase">Ping</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-download"></i> Recv</th>
                        <th class="p-3 text-left font-medium text-text-secondary uppercase"><i class="fas fa-upload"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in outbound_peers" :key="'outbound-' + peer.id" class="border-b border-border-strong hover:bg-border-strong/50 transition duration-150">
                        <td class="p-3">{{ peer.id }}</td>
                        <td class="p-3" :title="peer.addr">{{ peer.addr }}</td>
                        <td class="p-3" :title="peer.subver">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-3">{{ peer.version }}</td>
                        <td class="p-3">{{ formatTimeOffset(peer.timeoffset) }}</td>
                        <td class="p-3">{{ formatTimeSince(peer.conntime) }}</td>
                        <td class="p-3">{{ peer.network || 'N/A' }}</td>
                        <td class="p-3 font-medium text-accent" :title="'Connection type: ' + peer.connection_type">{{ peer.connection_type }}</td>
                        <td class="p-3">{{ formatPing(peer.minping) }}</td>
                        <td class="p-3" :title="peer.bytesrecv + ' Bytes'">{{ formatBytes(peer.bytesrecv) }}</td>
                        <td class="p-3" :title="peer.bytessent + ' Bytes'">{{ formatBytes(peer.bytessent) }}</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    // Destructure necessary functions from Vue
    const { createApp, ref, onMounted, reactive, toRefs, watch, computed, nextTick, onBeforeUnmount } = Vue;

    // Default data structure
    const DEFAULT_DATA = {
        stats: { inboundCount: 0, outboundCount: 0, totalPeers: 0 },
        blockchain: {
            blocks: 0,
            headers: 0,
            chain: 'Loading...',
            verificationProgress: 0,
            difficulty: 0,
            medianBlockSize: 0,
        },
        node: { version: 'N/A', protocolVersion: 'N/A', subversion: 'N/A' },
        upTime: 'N/A',
        inbound_peers: [],
        outbound_peers: [],
        subver_distribution: { inbound: [], outbound: [] }
    };


    /**
     * Generates a consistent set of colors for the charts.
     * Optimization: Moved color palette definition outside the function.
     */
    const BASE_COLORS = [
        '#00bcd4', '#ffc107', '#4caf50', '#f44336', '#9c27b0', '#ff9800', '#03a9f4', '#8bc34a',
        '#e91e63', '#607d8b', '#009688', '#cddc39', '#795548', '#ff5722', '#2196f3', '#673ab7'
    ];
    const generateColors = (numColors) => {
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            colors.push(BASE_COLORS[i % BASE_COLORS.length]);
        }
        return colors;
    };

    /**
     * Initializes a new Chart.js Pie instance.
     */
    const initPieChart = (canvasRef, chartData) => {
        if (!canvasRef.value) return null;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        const ctx = canvasRef.value.getContext('2d');
        return new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: percentages,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8,
                    borderColor: 'transparent',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                             boxWidth: 10,
                             color: Chart.defaults.color,
                        }
                    },
                    tooltip: {
                         mode: 'index',
                         intersect: false,
                         callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                if (label) {
                                    // Append percentage sign
                                    return label + ': ' + context.formattedValue + '%';
                                }
                                return null;
                            }
                         }
                    },
                    title: {
                        display: false,
                    }
                }
            }
        });
    };

    /**
     * Updates an existing Chart.js instance.
     */
    const updateChartData = (chartInstance, chartData) => {
        if (!chartInstance) return;

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = percentages;
        chartInstance.data.datasets[0].backgroundColor = backgroundColors;
        chartInstance.update();
    };


    const formatBytes = (bytes, decimals = 2) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        // Optimized: Changed 'Octets' to standard 'B' and translated unit names.
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };

    const formatTimeOffset = (timeoffset) => {
        if (timeoffset === undefined || timeoffset === null) return 'N/A';
        // Multiply by 1 is redundant if timeoffset is guaranteed to be a number, but keep for robustness if it might be a string.
        return (timeoffset * 1).toFixed(1) + ' s';
    };

    const formatTimeSince = (timestampOrTotalSeconds) => {
        if (!timestampOrTotalSeconds) return 'N/A';

        let totalSeconds;
        // If it's a Unix timestamp (conntime), calculate the difference
        if (timestampOrTotalSeconds > 1000000000) {
            const now = Date.now() / 1000;
            totalSeconds = Math.max(0, now - timestampOrTotalSeconds);
        } else {
            // Otherwise, assume it's already the total number of seconds
            totalSeconds = timestampOrTotalSeconds;
        }

        if (totalSeconds < 1) return '<1s';

        const s = Math.floor(totalSeconds % 60);
        const m = Math.floor((totalSeconds / 60) % 60);
        const h = Math.floor((totalSeconds / (60 * 60)) % 24);
        const d = Math.floor(totalSeconds / (60 * 60 * 24));

        const parts = [];
        if (d > 0) parts.push(d + "d");
        if (h > 0) parts.push(h + "h");
        if (m > 0) parts.push(m + "m");
        // Only show seconds if total time is less than a minute and we haven't added other units
        if (parts.length === 0 || totalSeconds < 60) parts.push(s + "s");

        // Limit to two units for conciseness
        return parts.slice(0, 2).join(' ');
    };

    const formatPing = (minping) => {
        if (minping === undefined || minping === null) return 'N/A';
        return minping > 0 ? minping.toFixed(3) + ' s' : 'N/A';
    };

    // ---------------------------------------------


    createApp({
        setup() {
            const isConnected = ref(false);
            const rpcConnected = ref(false);
            const errorMessage = ref(null);

            const isMobile = ref(window.innerWidth <= 600);

            const dataState = reactive(DEFAULT_DATA);
            let ws = null;

            const inboundChartCanvas = ref(null);
            const outboundChartCanvas = ref(null);
            let inboundPieChart = null;
            let outboundPieChart = null;

            const handleResize = () => {
                isMobile.value = window.innerWidth <= 600;
            };

            // Global Chart.js configuration for dark theme
            Chart.defaults.color = '#f0f0f0';
            Chart.defaults.borderColor = '#303030';
            Chart.defaults.plugins.tooltip.backgroundColor = '#1e1e1e';
            Chart.defaults.plugins.tooltip.bodyColor = '#f0f0f0';
            Chart.defaults.plugins.tooltip.titleColor = '#aaaaaa';
            Chart.defaults.plugins.tooltip.cornerRadius = 6;


            /** Updates reactive state with data received from the server. */
            const normalizeData = (rawData) => {
                const nodeInfo = rawData.nodeInfo || {};
                const blockchainInfo = rawData.blockchainInfo || {};

                Object.assign(dataState, {
                    stats: rawData.generalStats || {},
                    blockchain: {
                        blocks: blockchainInfo.blocks || 0,
                        headers: blockchainInfo.headers || 0,
                        chain: blockchainInfo.chain || 'N/A',
                        verificationProgress: blockchainInfo.verificationprogress || 0,
                        difficulty: blockchainInfo.difficulty || 0,
                        medianBlockSize: blockchainInfo.medianBlocksize || 0,
                    },
                    node: {
                        version: nodeInfo.version,
                        protocolVersion: nodeInfo.protocolversion,
                        subversion: nodeInfo.subversion,
                    },
                    // upTime is expected to be a pre-formatted string from the server
                    upTime: rawData.upTime || 'N/A',
                    inbound_peers: rawData.inboundPeer || [],
                    outbound_peers: rawData.outboundPeer || [],
                    subver_distribution: rawData.subverDistribution || { inbound: [], outbound: [] },
                });
            };

            /** Computes the cleaned Subversion string. */
            const cleanedSubversion = computed(() => {
                const subver = dataState.node.subversion;
                if (!subver || subver === 'N/A') return 'N/A';
                // Remove leading/trailing slashes and trim whitespace
                return subver.replace(/^\/|\/$/g, '').trim();
            });

            /** Destroys existing Chart.js instances. */
            const destroyCharts = () => {
                if (inboundPieChart) {
                    inboundPieChart.destroy();
                    inboundPieChart = null;
                }
                if (outboundPieChart) {
                    outboundPieChart.destroy();
                    outboundPieChart = null;
                }
            };


            /** Initializes and manages the WebSocket connection. */
            const connectWebSocket = () => {
                // Cleanup existing connection
                if (ws) {
                    ws.onclose = null; // Prevent onclose from triggering reconnect on manual close
                    ws.close();
                }

                // Determine WebSocket protocol (wss: for https:, ws: for http:)
                const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
                const hostAndPort = location.host;

                ws = new WebSocket(wsProtocol+ '//' + hostAndPort +'/ws/dashboard');

                ws.onopen = () => {
                    console.log("WebSocket connected!");
                    isConnected.value = true;
                };

                ws.onmessage = (event) => {
                    try {
                        const json = JSON.parse(event.data);

                        // Check for connection status message first
                        if (json.hasOwnProperty('rpcConnected')) {
                            rpcConnected.value = json.rpcConnected;
                            errorMessage.value = json.errorMessage || null;
                            return;
                        }

                        // Process main dashboard data
                        if (json.hasOwnProperty('generalStats')) {
                            rpcConnected.value = true;
                            errorMessage.value = null;
                            normalizeData(json);
                        }

                    } catch (e) {
                        console.error("Error parsing JSON message from WebSocket:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    console.log("WebSocket disconnected. Retrying in 3s...");
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket disconnected from server. Retrying...';
                    // Reconnect logic
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    // Error will often be followed by onclose, but set state here just in case.
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket connection error.';
                };
            };

            onMounted(() => {
                connectWebSocket();
                window.addEventListener('resize', handleResize);

                // Service Worker Registration (PWA)
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => console.log('Service Worker registered. Scope:', registration.scope))
                        .catch(error => console.error('Service Worker registration failed:', error));
                }
            });

            onBeforeUnmount(() => {
                window.removeEventListener('resize', handleResize);
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }
                // Ensure charts are destroyed when component unmounts
                destroyCharts();
            });

            // Watch `rpcConnected` to destroy/recreate Chart.js instances
            watch(rpcConnected, (newVal) => {
                if (newVal) {
                     // Connection Restored: Create charts
                     nextTick(() => {
                        destroyCharts(); // Destroy old charts before recreating
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subver_distribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subver_distribution.outbound);
                    });
                } else {
                    // Connection Lost: Destroy charts to clean up DOM/memory
                    destroyCharts();
                }
            });

            // Watch for changes in subver_distribution data to update charts
            watch(() => dataState.subver_distribution.inbound, (newVal) => {
                if (inboundPieChart) { updateChartData(inboundPieChart, newVal); }
            }, { deep: true });

            watch(() => dataState.subver_distribution.outbound, (newVal) => {
                if (outboundPieChart) { updateChartData(outboundPieChart, newVal); }
            }, { deep: true });

            return {
                isConnected,
                rpcConnected,
                errorMessage,
                isMobile,
                ...toRefs(dataState),
                inboundChartCanvas,
                outboundChartCanvas,
                cleanedSubversion,
                formatBytes,
                formatTimeOffset,
                formatTimeSince,
                formatPing,
            };
        }
    }).mount('#app');
</script>

</body>
</html>