<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Node RPC Dashboard</title>

    <link rel="icon" type="image/svg+xml" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="apple-touch-icon" href="https://upload.wikimedia.org/wikipedia/commons/4/46/Bitcoin.svg">
    <link rel="manifest" href="/manifest.json">

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <script>
        // Configuration Tailwind pour utiliser les variables CSS et le mode sombre
        tailwind.config = {
            darkMode: 'class', // Permet de basculer avec une classe 'dark' sur <html>
            theme: {
                extend: {
                    colors: {
                        'bg-app': 'var(--bg-app)',
                        'bg-card': 'var(--bg-card)',
                        'border-strong': 'var(--border-strong)',
                        'text-primary': 'var(--text-primary)',
                        'text-secondary': 'var(--text-secondary)',
                        'accent': 'var(--accent)',
                        'status-success': 'var(--status-success)',
                        'status-error': 'var(--status-error)',
                        'status-warning': 'var(--status-warning)',
                    }
                }
            }
        }
    </script>

    <style>
        /* --- Light Mode (Default) Variables --- */
        :root {
            /* Backgrounds */
            --bg-app: #f7f7f7;
            --bg-card: #ffffff;
            /* Text & Borders */
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-strong: #e5e7eb;

            /* Accent & Status Colors */
            --accent: #ff9900;
            --status-success: #10b981;
            --status-error: #ef4444;
            --status-warning: #f59e0b;

            /* Couleur RGB pour l'animation pulse */
            --status-error-rgb: 239, 68, 68;
        }

        /* --- Dark Mode Variables --- */
        .dark {
            /* Backgrounds */
            --bg-app: #0d0d0d;
            --bg-card: #1a1a1a;
            /* Text & Borders */
            --text-primary: #f0f0f0;
            --text-secondary: #b0b0b0;
            --border-strong: #383838;

            /* Accent & Status Colors */
            --accent: #ff9900;
            --status-success: #06d6a0;
            --status-error: #ef476f;
            --status-warning: #ffd166;

            /* Couleur RGB pour l'animation pulse */
            --status-error-rgb: 239, 71, 111;
        }

        body {
            font-family: 'Roboto', sans-serif;
        }

        /* Pulse Animation for Disconnected state */
        .pulse-error {
            animation: pulse-error 2s infinite;
        }

        @keyframes pulse-error {
            0% {
                box-shadow: 0 0 0 0 rgba(var(--status-error-rgb), 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(var(--status-error-rgb), 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(var(--status-error-rgb), 0);
            }
        }

        /* Chart Styling */
        .chart-container {
            width: 100%;
            max-width: 450px;
            height: 350px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .chart-container canvas {
            flex-grow: 1;
            width: 100% !important;
            height: 100% !important;
            background-color: transparent !important;
        }

        /* Table Styling */
        .peer-table-wrapper {
            overflow-x: auto;
        }

        .peer-table {
            border-collapse: collapse;
            width: max-content;
            min-width: 100%;
        }

        .peer-table th,
        .peer-table td {
            white-space: nowrap;
        }

        /* Responsive Improvements */
        @media (max-width: 600px) {
            .status-bar.is-mobile {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .status-bar.is-mobile span,
            .status-bar.is-mobile p {
                width: 100%;
                text-align: left;
            }
        }
    </style>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
</head>

<body class="bg-bg-app text-text-primary leading-relaxed transition-colors duration-300">

<div id="app" class="p-2 md:p-6">
    <button @click="toggleDarkMode"
            class="fixed top-4 right-4 z-50 p-3 rounded-full bg-bg-card border border-border-strong text-text-primary text-xl shadow-lg hover:bg-border-strong/50 transition-all duration-200"
            title="Basculer Mode Clair/Foncé">
        <i :class="isDarkMode ? 'fas fa-sun' : 'fas fa-moon'"></i>
    </button>

    <div class="flex justify-center mb-12 mt-4 sm:mt-0">
        <h1
                class="text-accent text-3xl md:text-5xl font-extralight tracking-widest uppercase text-center">
            <i class="fab fa-bitcoin mr-2"></i> Bitcoin Node Dashboard
        </h1>
    </div>


    <div class="status-bar is-mobile flex justify-center items-center gap-4 sm:gap-10 p-5 md:p-6 mb-10 rounded-xl font-medium shadow-2xl transition-all duration-300 ease-in-out"
         :class="{
            'bg-status-success/10 border border-status-success text-status-success': isConnected && rpcConnected,
            'bg-status-error/10 border border-status-error text-status-error pulse-error': !isConnected || !rpcConnected
        }">
            <span :title="isConnected ? 'WebSocket link is active and open' : 'WebSocket disconnected. Retrying connection...'"
                  class="flex items-center">
                <i class="fas fa-network-wired mr-2 text-xl"></i> WebSocket: {{ isConnected ? 'CONNECTED' : 'DISCONNECTED' }}
            </span>
        <span :title="rpcConnected ? 'Node is responding to RPC commands' : 'RPC connection lost or not yet established'"
              class="flex items-center">
                <i class="fas fa-server mr-2 text-xl"></i> Node RPC: {{ rpcConnected ? 'ONLINE' : 'OFFLINE' }}
            </span>
        <p v-if="errorMessage" class="text-sm font-light mt-1 pt-1 sm:border-t-0 sm:pt-0">
            <i class="fas fa-exclamation-circle mr-2"></i> {{ errorMessage }}
        </p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

        <div class="lg:col-span-2 mb-5" v-if="rpcConnected">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">

                <div
                        class="stat-card bg-bg-card p-6 rounded-xl shadow-lg border-l-4 border-status-success hover:shadow-2xl hover:border-accent transition duration-300 transform hover:-translate-y-0.5 flex flex-col gap-3">
                    <div class="flex justify-between items-center">
                        <div class="icon text-3xl text-status-success"><i class="fas fa-user-friends"></i></div>
                        <div class="label text-xs uppercase text-text-secondary font-medium">Total Peers</div>
                    </div>
                    <div class="value text-5xl font-light text-text-primary">{{ stats.totalPeers }}</div>
                    <div class="detail mt-2 pt-2 border-t border-border-strong text-sm text-text-secondary font-light">
                        <p class="mb-1"><i class="fas fa-sign-in-alt mr-1"></i> Inbound: {{ stats.inboundCount }}</p>
                        <p class="mb-1"><i class="fas fa-sign-out-alt mr-1"></i> Outbound: {{ stats.outboundCount }}</p>
                    </div>
                </div>

                <div
                        class="stat-card bg-bg-card p-6 rounded-xl shadow-lg border-l-4 border-status-warning hover:shadow-2xl hover:border-accent transition duration-300 transform hover:-translate-y-0.5 flex flex-col gap-3">
                    <div class="flex justify-between items-center">
                        <div class="icon text-3xl text-status-warning"><i class="fas fa-cubes"></i></div>
                        <div class="label text-xs uppercase text-text-secondary font-medium">Current Block</div>
                    </div>
                    <div class="value text-5xl font-light text-text-primary"
                         :title="'Current height of the ' + blockchain.chain + ' blockchain'">{{ blockchain.blocks }}
                    </div>

                    <div class="detail mt-2 pt-2 border-t border-border-strong text-sm text-text-secondary font-light">
                        <p class="mb-1"><i class="fas fa-list-ol mr-1"></i> Headers: <span
                                class="font-bold text-text-primary">{{ blockchain.headers }}</span></p>
                        <p class="mb-1"><i class="far fa-clock mr-1"></i> Time: <span
                                class="font-bold text-text-primary">{{ formatTimeSince(block.time) }} ago</span></p>
                        <p class="mb-1"><i class="fas fa-exchange-alt mr-1"></i> Tx Count: <span
                                class="font-bold text-text-primary">{{ block.ntx }}</span></p>
                    </div>
                </div>

                <div
                        class="stat-card bg-bg-card p-6 rounded-xl shadow-lg border-l-4 border-accent hover:shadow-2xl hover:border-accent transition duration-300 transform hover:-translate-y-0.5 flex flex-col gap-3 lg:col-span-2">
                    <div class="flex justify-between items-center">
                        <div class="icon text-3xl text-accent"><i class="fas fa-hard-hat"></i></div>
                        <div class="label text-xs uppercase text-text-secondary font-medium">Node Details</div>
                    </div>

                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-end mt-2">
                        <div class="min-w-0 flex-shrink">
                            <div class="value text-2xl font-bold text-text-primary truncate"
                                 :title="cleanedSubversion">{{ cleanedSubversion }}</div>
                            <div class="detail text-sm text-text-secondary font-light">Protocol v{{ node.protocolVersion }}
                            </div>
                        </div>

                        <div class="text-left sm:text-right mt-3 sm:mt-0 flex-shrink-0">
                            <div class="value text-2xl font-bold text-text-primary"
                                 title="Time elapsed since node started">{{ upTime }}</div>
                            <div class="detail text-sm text-text-secondary font-light">Uptime</div>
                        </div>
                    </div>
                    <div class="detail mt-3 pt-3 border-t border-border-strong text-sm text-text-secondary">
                        <p class="mb-1">
                            <i class="fas fa-shield-alt mr-1 text-status-success"></i> Verification Progress:
                            <span class="font-bold text-text-primary ml-1">{{ (blockchain.verificationProgress *
                                    100).toFixed(4) }}%</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-else-if="isConnected && !rpcConnected">
            <p class="text-center text-text-secondary text-lg">
                <i class="fas fa-spinner fa-spin mr-2"></i> Connecting to node RPC...
            </p>
        </div>

        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-2xl font-medium mb-6"><i class="fas fa-chart-pie mr-2 text-accent"></i> Peer Software Distribution</h2>

            <div class="flex flex-col md:flex-row gap-8 mt-4">

                <div class="sub-card flex-1 p-0 flex flex-col gap-4 border border-border-strong rounded-lg p-4">
                    <h4
                            class="text-lg font-bold uppercase text-center pb-2 border-b-2 border-status-success tracking-wider text-status-success">
                        <i class="fas fa-arrow-alt-circle-down mr-1"></i> Inbound Peers ({{ stats.inboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="inboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <div class="sub-card flex-1 p-0 flex flex-col gap-4 border border-border-strong rounded-lg p-4">
                    <h4
                            class="text-lg font-bold uppercase text-center pb-2 border-b-2 border-accent tracking-wider text-accent">
                        <i class="fas fa-arrow-alt-circle-up mr-1"></i> Outbound Peers ({{ stats.outboundCount }})
                    </h4>
                    <div class="flex flex-col items-center justify-center h-full">
                        <div class="chart-container">
                            <canvas ref="outboundChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="data-section bg-bg-card p-6 rounded-xl shadow-2xl lg:col-span-2" v-if="rpcConnected">
            <h2 class="text-2xl font-medium mb-6"><i class="fas fa-table mr-2 text-accent"></i> Connection Details</h2>

            <h4 class="text-xl font-medium mt-4 border-b border-border-strong pb-2 text-status-success">Inbound Peers ({{ inbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4 shadow-inner">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong/50">
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">ID</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Address</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Software (SubVer)</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Version</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Time Offset</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Connection Time</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Network</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Type</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Ping</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase"><i
                                class="fas fa-arrow-down text-status-success"></i> Received</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase"><i
                                class="fas fa-arrow-up text-accent"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in inbound_peers" :key="'inbound-' + peer.id"
                        class="border-b border-border-strong/70 hover:bg-bg-card/70 transition duration-150">
                        <td class="p-4 font-light">{{ peer.id }}</td>
                        <td class="p-4 font-light" :title="peer.addr">{{ peer.addr }}</td>
                        <td class="p-4 font-light" :title="peer.subver">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-4 font-light">{{ peer.version }}</td>
                        <td class="p-4 font-light">{{ formatTimeOffset(peer.timeoffset) }}</td>
                        <td class="p-4 font-light">{{ formatTimeSince(peer.conntime) }} ago</td>
                        <td class="p-4 font-light">{{ peer.network || 'N/A' }}</td>
                        <td class="p-4 font-medium text-status-success"
                            :title="'Connection type: ' + peer.connection_type">{{ peer.connection_type }}</td>
                        <td class="p-4 font-light">{{ formatPing(peer.minping) }}</td>
                        <td class="p-4 font-light" :title="peer.bytesrecv + ' Bytes'">{{ formatBytes(peer.bytesrecv) }}
                        </td>
                        <td class="p-4 font-light" :title="peer.bytessent + ' Bytes'">{{ formatBytes(peer.bytessent) }}
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h4 class="text-xl font-medium mt-8 border-b border-border-strong pb-2 text-accent">Outbound Peers ({{ outbound_peers.length }})</h4>
            <div class="peer-table-wrapper border border-border-strong rounded-lg mt-4 shadow-inner">
                <table class="peer-table w-full text-sm">
                    <thead>
                    <tr class="bg-border-strong/50">
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">ID</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Address</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Software (SubVer)</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Version</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Time Offset</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Connection Time</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Network</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Type</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase">Ping</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase"><i
                                class="fas fa-arrow-down text-status-success"></i> Received</th>
                        <th class="p-4 text-left font-semibold text-text-secondary uppercase"><i
                                class="fas fa-arrow-up text-accent"></i> Sent</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="peer in outbound_peers" :key="'outbound-' + peer.id"
                        class="border-b border-border-strong/70 hover:bg-bg-card/70 transition duration-150">
                        <td class="p-4 font-light">{{ peer.id }}</td>
                        <td class="p-4 font-light" :title="peer.addr">{{ peer.addr }}</td>
                        <td class="p-4 font-light" :title="peer.subver">{{ peer.subver || '[Empty]' }}</td>
                        <td class="p-4 font-light">{{ peer.version }}</td>
                        <td class="p-4 font-light">{{ formatTimeOffset(peer.timeoffset) }}</td>
                        <td class="p-4 font-light">{{ formatTimeSince(peer.conntime) }} ago</td>
                        <td class="p-4 font-light">{{ peer.network || 'N/A' }}</td>
                        <td class="p-4 font-medium text-accent"
                            :title="'Connection type: ' + peer.connection_type">{{ peer.connection_type }}</td>
                        <td class="p-4 font-light">{{ formatPing(peer.minping) }}</td>
                        <td class="p-4 font-light" :title="peer.bytesrecv + ' Bytes'">{{ formatBytes(peer.bytesrecv) }}
                        </td>
                        <td class="p-4 font-light" :title="peer.bytessent + ' Bytes'">{{ formatBytes(peer.bytessent) }}
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    const { createApp, ref, onMounted, reactive, toRefs, watch, computed, nextTick, onBeforeUnmount } = Vue;

    const DEFAULT_DATA = {
        stats: { inboundCount: 0, outboundCount: 0, totalPeers: 0 },
        blockchain: {
            blocks: 0,
            headers: 0,
            chain: 'Loading...',
            verificationProgress: 0,
            difficulty: 0,
            medianBlockSize: 0,
        },
        node: { version: 'N/A', protocolVersion: 'N/A', subversion: 'N/A' },
        upTime: 'N/A',
        inboundPeers: [],
        outboundPeers: [],
        subverDistribution: { inbound: [], outbound: [] },
        block: {},
    };

    const BASE_COLORS = [
        '#06d6a0', '#ff9900', '#ef476f', '#118ab2', '#ffd166', '#00bcd4', '#4caf50', '#9c27b0',
        '#ff9800', '#03a9f4', '#8bc34a', '#e91e63', '#607d8b', '#009688', '#cddc39', '#795548'
    ];

    // --- Fonctions utilitaires ---

    const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    const generateColors = (numColors) => {
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            colors.push(BASE_COLORS[i % BASE_COLORS.length]);
        }
        return colors;
    };

    const updateChartDefaults = () => {
        // Ces valeurs s'appliquent aux axes et aux ticks (si le graphique en avait).
        Chart.defaults.color = getCssVar('--text-primary');
        Chart.defaults.borderColor = getCssVar('--border-strong');
    };

    // NOUVEAU: Facteurs les options dynamiques de Chart.js
    const getChartOptions = () => {
        return {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 10,
                        color: getCssVar('--text-primary'), // Couleur dynamique
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    // Couleurs dynamiques pour le Tooltip
                    backgroundColor: getCssVar('--bg-card'),
                    bodyColor: getCssVar('--text-primary'),
                    titleColor: getCssVar('--text-secondary'),
                    cornerRadius: 6,
                    callbacks: {
                        label: function (context) {
                            const label = context.label || '';
                            if (label) {
                                return label + ': ' + context.formattedValue + '%';
                            }
                            return null;
                        }
                    }
                },
                title: {
                    display: false,
                }
            }
        };
    };

    const initPieChart = (canvasRef, chartData) => {
        if (!canvasRef.value) return null;

        updateChartDefaults();

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        const ctx = canvasRef.value.getContext('2d');
        return new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: percentages,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8,
                    borderColor: 'transparent',
                }]
            },
            // Utilisation des options factorisées
            options: getChartOptions()
        });
    };

    const updateChartData = (chartInstance, chartData) => {
        if (!chartInstance) return;

        updateChartDefaults();

        const labels = chartData.map(d => d.server || '[Unknown]');
        const percentages = chartData.map(d => d.percentage);
        const backgroundColors = generateColors(labels.length);

        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = percentages;
        chartInstance.data.datasets[0].backgroundColor = backgroundColors;

        // Mise à jour explicite des options basées sur le thème actuel (pour les mises à jour de données)
        const options = getChartOptions();
        chartInstance.options.plugins.legend.labels.color = options.plugins.legend.labels.color;
        chartInstance.options.plugins.tooltip.backgroundColor = options.plugins.tooltip.backgroundColor;
        chartInstance.options.plugins.tooltip.bodyColor = options.plugins.tooltip.bodyColor;
        chartInstance.options.plugins.tooltip.titleColor = options.plugins.tooltip.titleColor;

        chartInstance.update();
    };

    // Fonctions de formatage (laissées ici pour la clarté)
    const formatBytes = (bytes, decimals = 2) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };

    const formatTimeOffset = (timeoffset) => {
        if (timeoffset === undefined || timeoffset === null) return (0).toFixed(1) + ' s';
        return (timeoffset * 1).toFixed(1) + ' s';
    };

    const formatTimeSince = (timestampOrTotalSeconds) => {
        if (!timestampOrTotalSeconds) return 'N/A';

        let totalSeconds;
        if (timestampOrTotalSeconds > 1000000000) {
            const now = Date.now() / 1000;
            totalSeconds = Math.max(0, now - timestampOrTotalSeconds);
        } else {
            totalSeconds = timestampOrTotalSeconds;
        }

        if (totalSeconds < 1) return '<1s';

        const s = Math.floor(totalSeconds % 60);
        const m = Math.floor((totalSeconds / 60) % 60);
        const h = Math.floor((totalSeconds / (60 * 60)) % 24);
        const d = Math.floor(totalSeconds / (60 * 60 * 24));

        const parts = [];
        if (d > 0) parts.push(d + "d");
        if (h > 0) parts.push(h + "h");
        if (m > 0) parts.push(m + "m");
        if (parts.length === 0 || totalSeconds < 60) parts.push(s + "s");

        return parts.slice(0, 2).join(' ');
    };

    const formatPing = (minping) => {
        if (minping === undefined || minping === null || minping === 0) return 'N/A';
        return minping.toFixed(3) + ' s';
    };

    // ---------------------------------------------


    createApp({
        setup() {
            const isConnected = ref(false);
            const rpcConnected = ref(false);
            const errorMessage = ref(null);
            const isDarkMode = ref(true);

            const dataState = reactive(DEFAULT_DATA);
            let ws = null;

            const inboundChartCanvas = ref(null);
            const outboundChartCanvas = ref(null);
            let inboundPieChart = null;
            let outboundPieChart = null;


            const updateErrorPulseRgb = () => {
                const errorColor = isDarkMode.value ? '239, 71, 111' : '239, 68, 68';
                document.documentElement.style.setProperty('--status-error-rgb', errorColor);
            };


            const toggleDarkMode = () => {
                isDarkMode.value = !isDarkMode.value;
                localStorage.setItem('theme', isDarkMode.value ? 'dark' : 'light');

                // IMPORTANT: Appliquer la classe 'dark' sur <html> pour garantir la résolution CSS des variables.
                document.documentElement.classList.toggle('dark', isDarkMode.value);

                updateErrorPulseRgb();

                // Détruire et recréer les graphiques pour appliquer les nouvelles couleurs du thème
                destroyCharts();
                nextTick(() => {
                    if (rpcConnected.value) {
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subverDistribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subverDistribution.outbound);
                    }
                });
            };

            const loadTheme = () => {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    isDarkMode.value = savedTheme === 'dark';
                } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    isDarkMode.value = true;
                } else {
                    isDarkMode.value = false;
                }

                // IMPORTANT: Appliquer la classe 'dark' sur <html> au chargement
                if (isDarkMode.value) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }

                updateErrorPulseRgb();
            };


            const normalizeData = (rawData) => {
                const nodeInfo = rawData.nodeInfo || {};
                const blockchainInfo = rawData.blockchainInfo || {};

                Object.assign(dataState, {
                    stats: rawData.generalStats || {},
                    blockchain: {
                        blocks: blockchainInfo.blocks || 0,
                        headers: blockchainInfo.headers || 0,
                        chain: blockchainInfo.chain || 'N/A',
                        verificationProgress: blockchainInfo.verificationprogress || 0,
                        difficulty: blockchainInfo.difficulty || 0,
                        medianBlockSize: blockchainInfo.medianBlocksize || 0,
                    },
                    node: {
                        version: nodeInfo.version,
                        protocolVersion: nodeInfo.protocolversion,
                        subversion: nodeInfo.subversion,
                    },
                    upTime: rawData.upTime || 'N/A',
                    inboundPeers: rawData.inboundPeer || [],
                    outboundPeers: rawData.outboundPeer || [],
                    subverDistribution: rawData.subverDistribution || { inbound: [], outbound: [] },
                    block: rawData.blockInfo || {},
                });
            };

            const cleanedSubversion = computed(() => {
                const subver = dataState.node.subversion;
                if (!subver || subver === 'N/A') return 'N/A';
                return subver.replace(/^\/|\/$/g, '').trim();
            });

            const destroyCharts = () => {
                if (inboundPieChart) {
                    inboundPieChart.destroy();
                    inboundPieChart = null;
                }
                if (outboundPieChart) {
                    outboundPieChart.destroy();
                    outboundPieChart = null;
                }
            };


            const connectWebSocket = () => {
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }

                const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
                const hostAndPort = location.host;

                ws = new WebSocket(wsProtocol + '//' + hostAndPort + '/ws/dashboard');

                ws.onopen = () => {
                    isConnected.value = true;
                };

                ws.onmessage = (event) => {
                    try {
                        const json = JSON.parse(event.data);

                        if (json.hasOwnProperty('rpcConnected')) {
                            rpcConnected.value = json.rpcConnected;
                            errorMessage.value = json.errorMessage || null;
                            return;
                        }

                        if (json.hasOwnProperty('generalStats')) {
                            rpcConnected.value = true;
                            errorMessage.value = null;
                            normalizeData(json);
                        }

                    } catch (e) {
                        console.error("Error parsing JSON message from WebSocket:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket disconnected from server. Retrying...';
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    isConnected.value = false;
                    rpcConnected.value = false;
                    errorMessage.value = 'WebSocket connection error.';
                };
            };

            onMounted(() => {
                loadTheme();
                updateChartDefaults();
                connectWebSocket();

                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => console.log('Service Worker registered. Scope:', registration.scope))
                        .catch(error => console.error('Service Worker registration failed:', error));
                }
            });

            onBeforeUnmount(() => {
                if (ws) {
                    ws.onclose = null;
                    ws.close();
                }
                destroyCharts();
            });

            watch(rpcConnected, (newVal) => {
                if (newVal) {
                    nextTick(() => {
                        destroyCharts();
                        inboundPieChart = initPieChart(inboundChartCanvas, dataState.subverDistribution.inbound);
                        outboundPieChart = initPieChart(outboundChartCanvas, dataState.subverDistribution.outbound);
                    });
                } else {
                    destroyCharts();
                }
            });

            // Les watchers appellent maintenant la version optimisée d'updateChartData
            watch(() => dataState.subverDistribution.inbound, (newVal) => {
                if (inboundPieChart) { updateChartData(inboundPieChart, newVal); }
            }, { deep: true });

            watch(() => dataState.subverDistribution.outbound, (newVal) => {
                if (outboundPieChart) { updateChartData(outboundPieChart, newVal); }
            }, { deep: true });

            return {
                isConnected,
                rpcConnected,
                errorMessage,
                isDarkMode,
                toggleDarkMode,
                ...toRefs(dataState),
                inbound_peers: computed(() => dataState.inboundPeers),
                outbound_peers: computed(() => dataState.outboundPeers),
                subver_distribution: computed(() => dataState.subverDistribution),
                inboundChartCanvas,
                outboundChartCanvas,
                cleanedSubversion,
                // Fonctions de formatage exposées pour le template
                formatBytes,
                formatTimeOffset,
                formatTimeSince,
                formatPing,
            };
        }
    }).mount('#app');
</script>

</body>

</html>